---
title: 面试题
tags: 前端面试题汇总
abbrlink: 1376120437
date: 2023-10-14 16:43:03
---

## css

### 快速布局上下左右居中对齐

> 将body设置成 `display: flex;` ，给需要布局的盒子在有宽高的前提下设置 `marin: auto;`

### padding与margin的区别

> padding为盒子的内边距，margin为外边距
> 作用对象不同，padding是作用域自身的，而margin是作用外部对象的外部

### vw与百分比的区别

> 百分比具有继承关系，而vw只和设备的宽度有关系


### 如何让谷歌浏览器支持小字体

> 浏览器默认支持最小字体为 `font-size：12px`,再缩小就需要为添加 `tarnsform属性`使其变为原来的多少倍。
```css
.small-font{
transform: scale(0.8);
-webkit-transform: scale(e.8);}
```

### 行内元素和块级元素

行内元素和块级元素是HTML和CSS中两种基本的元素显示方式。它们之间的主要区别如下：

1. **显示方式**：
    - **块级元素**：独占一行，即使内容没有充满整个行宽，它仍然会拓展到其容器的整个宽度。常见的块级元素包括：`<div>`, `<p>`, `<h1>~<h6>`, `<ul>`, `<li>`, `<ol>` 等。
    - **行内元素**：与其他行内元素并排显示在同一行，只占据其内容所需要的宽度。常见的行内元素包括：`<span>`, `<a>`, `<strong>`, `<em>`, `<abbr>` 等。

2. **尺寸设置**：
    - **块级元素**：可以设置宽度和高度。如果不设置宽度，默认为其父元素的宽度；如果不设置高度，默认为其内容的高度。
    - **行内元素**：设置宽度和高度通常无效，它的宽高由其内容决定。

3. **margin和padding**：
    - **块级元素**：上下左右的`margin`和`padding`都会生效。
    - **行内元素**：左右的`margin`和`padding`会生效，但上下的通常不会改变元素的高度，而是影响其上下元素的距离。

4. **用途**：
    - **块级元素**：通常用于布局和结构化页面内容。
    - **行内元素**：通常用于修饰或突出显示文本内容。

5. **转换**：
    - 通过CSS的`display`属性，我们可以转换元素的显示方式。例如，将行内元素转为块级元素可以设置`display: block;`，而将块级元素转为行内元素可以设置`display: inline;`。

6. **默认样式**:
    - **块级元素**：除了默认独占一行，它们往往还有一些其他默认的样式。例如，`<p>` 元素通常具有默认的上下 `margin`，而 `<ul>` 列表会有默认的 `padding` 和 `list-style`。
    - **行内元素**：默认没有上下 `margin` 和 `padding`。例如，`<span>` 和 `<a>` 标签通常不会为你添加任何额外的空间。

7. **布局特点**：
    - **块级元素**：更容易用于CSS布局技术，如Flexbox和Grid。这是因为它们天然具有清晰的尺寸和结构定义。
    - **行内元素**：对于Flexbox和Grid布局，你可能需要将它们转换为块级元素或 `inline-block` 来更好地控制它们。

8. **嵌套规则**：
    - **块级元素**：可以包含其他块级元素和行内元素。
    - **行内元素**：通常只能包含其他行内元素，不建议包含块级元素。例如，尽管一些浏览器可能会渲染嵌套在 `<span>` 内部的 `<div>`，但这种做法违反了HTML的标准，可能导致不可预测的布局问题。

9. **上下文关系**：
    - 有时候，元素的 `display` 值会因为它们所处的上下文而改变。例如，当 `li` 元素处于 `ul` 或 `ol` 中时，它是块级元素，但如果它不在这些上下文中，它可能不会表现为块级元素。

10.  **现代CSS布局**：
    - 随着现代CSS布局方法，如Flexbox和Grid的出现，`display` 属性的值变得更加复杂和多样。例如，使用 `display: flex;` 会使容器变成一个Flex容器，其子元素默认表现为Flex项目。这意味着即使子元素原本是行内元素，它们现在也会有块级元素的一些特性。

注意：在实际开发中，还有一种常见的`display`属性值是`inline-block`，这种元素结合了块级元素和行内元素的特点，即它既可以设置宽度和高度，又能与其他元素在同一行显示。

## JavaScript

### let与var的区别（Es6）

在ECMAScript 6 (ES6) 或者称为 ECMAScript 2015 中，`let` 和 `var` 是两种用于声明变量的关键字。它们在作用域、提升等方面有一些明显的区别。以下是它们之间的主要区别：

1. **块级作用域**：
    - `let`: `let`声明的变量仅在其所在的块内部可见。一个块是由大括号 `{}` 包围的代码段，例如函数、循环或if语句。
    - `var`: `var`声明的变量在其整个封闭函数内可见，而不仅仅是块内部。（没有局部作用域，红杏出墙）

2. **变量提升**: 
    - `let`: `let`声明的变量会被提升，但是你不能在声明之前访问它，否则会抛出一个错误。这种区域被称为“暂时性死区”（Temporal Dead Zone, TDZ）。
    - `var`: `var`声明的变量也会被提升到函数的顶部，但你可以在声明前访问它，此时它的值是`undefined`。（变量提升，可以先上车再买票）

3. **重新声明**: 
    - `let`: 在同一作用域内，不能使用`let`重新声明一个已经存在的变量名。
    - `var`: 在同一作用域内，可以多次使用`var`声明相同的变量名，而不会报错。（可以重复声明相同变量，如套牌车）

4. **全局对象属性**:
    - `let`: 当在全局作用域使用`let`声明变量时，该变量不会成为全局对象（例如在浏览器中的`window`对象）的属性。
    - `var`: 当在全局作用域使用`var`声明变量时，该变量会成为全局对象的属性。

5. **在循环中的行为**:
    - `let`: 在for循环的初始化部分使用`let`声明的变量，对于每次迭代都会有一个新的绑定，这尤其在创建闭包时非常有用。
    - `var`: 使用`var`在for循环中声明的变量，所有迭代共享同一变量。

6. **关于严格模式**:
    - `let`: 在ECMAScript 6及以后的版本中，`let`默认就是在严格模式下执行的，不需要额外声明。
    - `var`: 除非在代码中明确使用`"use strict";`，否则使用`var`声明的变量不会强制执行严格模式。

7. **创建全局变量**:
    - `let`: 在顶级作用域（非函数内）使用`let`声明的变量不会创建一个新的全局变量。它只是创建一个块级绑定，你不能通过`window.myVariable`这样的方式访问它（如果是在浏览器环境下）。
    - `var`: 在顶级作用域声明的`var`变量会成为全局对象的一个属性。

8. **初始化的要求**:
    - `let`: `let`声明的变量必须在使用前初始化，否则会抛出一个错误。
    - `var`: `var`声明的变量可以在使用前不初始化，此时它的值默认为`undefined`。

9. **在浏览器环境中的差异**:
    - `let`: 使用`let`在浏览器中声明的变量（在顶层作用域）不会成为`window`对象的属性。
    - `var`: 使用`var`在浏览器的顶层作用域声明的变量会自动成为`window`对象的一个属性。

10. **性能**:
    - 在某些JavaScript引擎中，由于`let`的语义和块级作用域特性，使用`let`可能会带来轻微的性能提升。然而，在日常开发中，这种差异通常可以忽略不计。

总结：

随着现代JavaScript的发展，`let`和`const`（另一个块级作用域的声明，用于创建常量）成为了首选的变量声明方式，因为它们提供了更清晰和更有预测性的代码行为。然而，仍然存在大量使用`var`的旧代码，因此理解`var`的工作方式也很重要。

对于新项目或现有项目的维护，推荐使用`let`和`const`来提高代码的可读性和可维护性。

### 深拷贝与浅拷贝的区别

深拷贝和浅拷贝是编程中常见的两种数据复制方式。这两种方式的主要区别在于它们如何复制对象的值以及对象引用其他对象时的行为。以下是它们之间的主要区别和细节：

1. **浅拷贝**:
    - 只复制对象的顶层属性。
    - 如果对象的属性值是基本类型（如字符串、数字、布尔值等），则直接复制该值。
    - 如果对象的属性值是引用类型（如数组、对象等），则复制该引用（地址），而不是实际的对象。这意味着原对象和复制的对象都引用相同的子对象。

2. **深拷贝**:
    - 复制对象及其所有嵌套对象。
    - 无论属性值是基本类型还是引用类型，都会为新对象创建一个新的副本。
    - 深拷贝会遍历整个对象及其所有子对象，以确保创建完整的复制副本。

举个例子来说明两者的区别：

```javascript
let obj1 = {
    a: 1,
    b: { c: 2 }
};

// 浅拷贝
let shallowCopy = Object.assign({}, obj1);

// 深拷贝（一个简单的方法，但并不完美）
let deepCopy = JSON.parse(JSON.stringify(obj1));

// 修改原对象
obj1.b.c = 3;

console.log(obj1.b.c);          // 输出: 3
console.log(shallowCopy.b.c);  // 输出: 3，因为它与obj1共享同一个子对象
console.log(deepCopy.b.c);     // 输出: 2，因为它是子对象的一个完全独立的复制
```

需要注意的是，使用`JSON.parse(JSON.stringify(obj))`进行深拷贝存在一些局限性：

- 它不能复制函数、`undefined`、`RegExp`、`Symbol`、特殊的对象如`Error`、`Date`等。
- 它不能复制对象的原型链。
- 它不能处理循环引用的情况。

在实践中，可以使用像 lodash 的 `_.cloneDeep()` 这样的库函数来进行可靠的深拷贝。

理解深拷贝和浅拷贝对于避免在处理对象和数组时出现不可预期的副作用是很重要的。

例如：
1. **第一段代码**：(浅拷贝)
```javascript
let arr =[1,2,3];
let newArr = arr; 
newArr.push(4)
console.log(arr, newArr);
```
结果将是：`[1,2,3,4] [1,2,3,4]`
这是因为`newArr`和`arr`都引用同一个数组。当你更改`newArr`时，`arr`也会受到影响。

2. **第二段代码**：(结构赋值为深拷贝)
```javascript
let arr = [1,2,3];
let newArr = [...arr];
newArr.push(4);
console.log(arr, newArr);
```
结果将是：`[1,2,3] [1,2,3,4]`
使用`...`运算符进行数组解构赋值，它创建了原数组的一个深拷贝。因此，`newArr`和`arr`是两个不同的数组。

3. **第三段代码**：
```javascript
let arr2 = [[1,2,3],[4,5,6]];
let newArr2 = [...arr2];
newArr2[0].push(888);
console.log(arr2, newArr2);
```
结果将是：`[[1,2,3,888],[4,5,6]] [[1,2,3,888],[4,5,6]]`
这是因为虽然我们使用了`...`运算符创建了`arr2`的一个浅拷贝，但数组中的子数组仍然是通过引用共享的。所以，当你修改`newArr2`中的子数组时，`arr2`中对应的子数组也会受到影响。

结论：解构赋值对于一维数组和对象来说，表现得像深拷贝；但对于多维数组或对象中包含对象的情况，它是浅拷贝。

**手写深拷贝**
```js
/**
 * 深拷贝函数
 * @param {*} source - 要拷贝的源对象或数组
 * @returns {*} 拷贝后的新对象或数组
 */
function deepClone(source) {
    // 如果source是null或非对象/数组，则直接返回source
    if (source === null || typeof source !== 'object') return source;

    // 根据source的类型（数组或对象）初始化一个新的targetObj
    const targetObj = source.constructor === Array ? [] : {};

    // 遍历source的每一个属性/元素
    for (let keys in source) {
        // 确保只拷贝source自身的属性，不拷贝原型链上的属性
        if (source.hasOwnProperty(keys)) {
            // 如果当前属性的值是对象或数组，则递归进行深拷贝
            if (source[keys] && typeof source[keys] === 'object') {
                // 维护层代码
                targetObj[keys] = sourece[keys].constructor === Array ? [] :{};
                // 递归
                targetObj[keys] = deepClone(source[keys]);
            } else {
                // 如果当前属性的值不是对象或数组，则直接赋值
                targetObj[keys] = source[keys];
            }
        }
    }
    // 返回深拷贝后的对象或数组
    return targetObj;
}

// 使用示例
const obj = {
    a: 1,
    b: [2, 3, { d: 4 }],
    c: { e: 5, f: { g: 6 } }
};
const clonedObj = deepClone(obj);
clonedObj.c.e=6;
clonedObj.b[0]=3;
console.log(clonedObj);  // { a: 1, b: [ 3, 3, { d: 4 } ], c: { e: 6, f: { g: 6 } } }
```

### 闭包(沟通内外方法的桥梁)
1. 闭包是什么？方法里返回一个方法
例如：
```js
    // 1. 闭包 : 内层函数 + 外层函数变量
    function outer() {
      const a = 1
      function f() {
        console.log(a)
      }
      f()
    }
    outer()
```
2. 闭包存在的意义？
+ 延长变量的生命周期
+ 创建私有环境
3. 闭包会常驻内存=>慎用闭包

**Vue data()**为什么是一个函数？
```js
let makeCounter = function () {
    let num = e;
    function changeBy(val){
        num += val
    }
    //给你什么，你才能拿
    return {
        add: function() {
            changeBy(1)
            }，
        redece: function() {
            changeBy(-1)
        },
        value: function() {
        return num
        }
    }
}

    let counter1 = makeCounter()
    let counter2 = makeCounter()
    counter1.add()
    counter1.add()// 2
    // counter2 // 0
    counter2.add()//
    console.log(counter2.value())// 1
    console.log(counter1.value())// 2
    // 两者互补干扰
```

### 作用域链
```js
let name = "小明"
function fn2(){
    let name = "小白";
    function fn3(){
        let name = "小红";
        console.log(name)
}
fn3()
}
fn2()
// 打印时会逐层查找，找到就输出。
```

### 防抖(英雄回城)

>防抖是指在一定时间间隔内，如果有连续的动作触发，只会执行最后一次。

```js
//防抖=>将多次操作变成一次
    let telInput = document.querySelector( ' input ' )
    telInput.addEventListener( 'input ', antiShake(demo，2000))
    //防抖封装
    function antiShake(fn，wait){
        let timeout = null;
        return args =>{
            if(timeOut) clearTimeout(timeOut)
            timeOut = setTimeout(fn,wait);
        }
    }
    function demo(){
    console.log('发起请求')
    }
```

### 节流(鼠标移动mousemove)

>节流是一种在一定时间段内只允许函数执行一次的技术。
应用场景：
+ 提交表单
+ 高频监听事件

```js
//节流=>一定时间内只调用一次函数
    let box = document.querySelector( ".box")
    function throttle(event，time){
        let timer = null
        return function() {
            if(!timer) {
                itimer = setTimeout(() =>{
                    event();
                    timer = null;
                }, time);
            }
        }
    }
```

### null与undefined

```js
    console.log(typeof null)//表示为“无”对象0
    console.log(typeof undefined)//表示“无”的原始值 NaN
    // undefined的几种情况
    // 1. 以声明，没赋值
    // 2. 访问对象上不存在的属性
    // 3. 在传参时少传参数
    // 4. 常规函数的默认返回值（构造函数除外，它返回的当前的构造对象）
    function fn(){
        console.log('123')
    }
    console.log(f()) //undefined

    // null的几种情况
    // 1. 手动释放内存
    let obj = {};
    obj = null;
    // 2. 作为函数的参数（此参数不是对象）
    // 3. 作为原型链的顶端
```

### foreach()与map()的区别
```js
    // foreach
    // 1. 没有返回值 undefined
    // 2. 不能用break，否则会报错
    // 3. 遍历的是value
    let arr = [ 'a', 'b', 'c']
    let res = arr.forEach(element =>{
    console.log(element)
    // break;
    return element + '1'
    }) //a b c
    // console.log(res)

    //map
    // 1. 有返回值（数组），默认return是undefined
    // 2. 接受的参数是一个函数(value,key)
    // 不能用break打断
    let arr = [ 'a', 'b', 'c']
    let res = arr.map((value,key) =>{
    // break;
    return value + '1'
    })
    console.log(res) //[a1,b1,c1]
```

### js递归求和

```js
    function add(num1,num2){
        let num = num1+num2;
        if( num2+1 > 100){
            return num;
        }else{
            return add(num,num2+1)
        }
    }
    let sum = add(1,2)
    console.log(sum)//5050
```

## Es6相关面试题

### var let和const

1. **var**:
    - **作用域**: 使用`var`声明的变量具有函数级作用域，这意味着在函数内声明的`var`变量可以在整个函数内部访问，但不受代码块（如`if`语句或`for`循环）的限制。
    - **提升**: `var`声明的变量会被提升至函数的顶部。这意味着在变量声明之前访问该变量会得到`undefined`，而不会产生错误。
    - **重复声明**: 在同一个作用域内可以多次使用`var`声明相同的变量名，而不会报错。

2. **let**:
    - **作用域**: `let`声明的变量具有块级作用域，因此在`for`循环或`if`语句等代码块中声明的`let`变量在代码块之外是不可见的。
    - **提升**: `let`声明的变量存在暂时性死区，意味着在声明之前访问它会产生错误。
    - **重复声明**: 在同一作用域内，不能使用`let`重复声明一个已经存在的变量名，坚持使用会抛出语法错误。

3. **const**:
    - **作用域**: 与`let`相同，`const`声明的变量具有块级作用域。
    - **不可变性**: `const`声明的变量必须在声明时进行初始化，且后续不可重新赋值。但需要注意的是，如果`const`声明的是对象或数组，你仍然可以修改它们的内部属性或元素，但不能重新分配整个对象或数组。
    - **重复声明**: 与`let`相同，`const`不允许在同一作用域内重复声明变量，坚持使用会抛出语法错误。

总结：在现代JavaScript编程中，推荐使用`let`和`const`而避免使用`var`，因为它们提供更严格和更易于预测的行为，特别是在复杂的应用和大型代码库中。

### 数组去重(技巧)
```js
let arr = [12,13,16,12,59]
let newarr = [...new Set(arr)]
console.log(newarr)
```

### Promise
```js
const promise = new Promise((resolve,reject) =>{
    console.log(1)
    resolve();
    console.log(2)
    }
    )
    promise.then(() =>{
        console.log(3)
        }
        )
    console.log(4)
```
打印结果为：1，2，4，3
**原因：**构造函数同步执行，`.then()` 为异步执行，所以说最后打印 3。

### filter (不影响原数组)
```js
    let a = [1，2，3，14，15]
    // 1. current =>当前值
    // 2. index =>当前值的下标
    // 3．array这个数组对象
    let b = a.filter((current，index，array) =>{
    return current > 10
    }
    console.log(a)
    console.log(b)
```